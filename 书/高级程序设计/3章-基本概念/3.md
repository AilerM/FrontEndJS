# 3章 基本概念

## 3.1语法

### 3.1.2标识符
  所谓标识符，就是指变量、函数、属性的名字，或者函数的参数。

## 3.2 关键字和保留字
关键字也是语言保留的，不能用作标识符
关键字作标识符，会导致“Identifier Expected”错误。
```js
debugger*
break        case
catch        continue
default      delete
do           instanceof
else         new
finally      return
for          switch
function     this
if           throw
in           try
typeof       var
void         while        with
```
能用作标识符的保留字
```js
class
enum
extends
super 12 synchronized
const
export
import

implements
package
public
interface
protected
private
static
yelid *
let *

abstract
boolean
byte
char
debugger
double
final
float
goto
int
long
native
short
throws
transient
volatile
```

## 3.3变量
在函数中使用 var 定义一个变量，那么这个变量在函数退出后就会被销毁

```js
function test(){
  message = "hi"; // 全局变量 
}
test();
alert(message); // "hi"
```

## 3.4数据类型

### 3.4.1 typeof操作符
ECMAScript 中有 5 种简单数据类型(也称为基本数据类型):
Undefined、Null、Boolean、Number 和 String。还有 1 种复杂数据类型——Object，**Object 本质上是由一组无序的名值对组成的**

### 3.4.2 Undefined类型
令人困惑的是:对未初始化的变量执行 typeof 操作符会返回 undefined 值，**而对未声明 的变量执行 typeof 操作符同样也会返回 undefined 值**。来看下面的例子:
```js
var message; // 这个变量声明之后默认取得了 undefined 值 // 下面这个变量并没有声明
 // var age
alert(typeof message);
alert(typeof age);
// "undefined"
// "undefined"
```   

### 3.4.3 Null类型
```js
var car = null;
alert(typeof car);
// "object"
```    
如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 null 而不是其他值。
实际上，undefined 值是派生自 null 值的，因此 ECMA-262 规定对它们的相等性测试要返回 true:
alert(null == undefined);    //true

都没有必要把一个变量的值显式地设置为 undefined，可是同样的规则对 null 却不适用。换句话说， **只要意在保存对象的变量还没有真正保存对象**，就应该明确地让该变量保存 null 值。这样做不仅可以 体现 null 作为空对象指针的惯例，而且也有助于进一步区分 null 和 undefined。

### 3.4.4 Boolean类型
转换为true的值 转换为false的值 任何非零数字值(包括无穷大) 0和NaN(参见本章后面有关NaN的内容)
```js
Boolean(-1) //true
Boolean(0) //false
Boolean({}) //true
Boolean(null) //false
```

### 3.4.5 Number类型
- 浮点数值
var floatNum = 3.125e7; // 等于31250000
e 表示法的实际含义就是“3.125 乘以 107”。
也可以使用 e 表示法表示极小的数值，如 0.00000000000000003，这个数值可以使用更简洁的 3e-17 表示。在默认情况下，ECMASctipt 会将那些小数点后面带有 **6** 个零以上的浮点数值转换为以 e 表示法 表示的数值(例如，0.0000003 会被转换成 3e-7)。

浮点数值的最高精度是 **17** 位小数，但在进行算术计算时其精确度远远不如整数。例如，0.1 加 0.2 的结果不是 0.3，而是 0.30000000000000004。这个小小的舍入误差会导致无法测试特定的浮点数值。

- 数值范围
如果某次计算的 结果得到了一个超出 JavaScript 数值范围的值，那么这个数值将被自动转换成特殊的 **Infinity** 值。具 体来说，如果这个数值是负数，则会被转换成-Infinity(负无穷)，如果这个数值是正数，则会被转 换成 Infinity(正无穷)。 

- NaN
首先，任何涉及 NaN 的操作(**例如 NaN/10)都会返回 NaN**，这 个特点在多步计算中有可能导致问题。其次，**NaN 与任何值都不相等**，包括 NaN 本身
```js
alert(isNaN(NaN)); // true
alert(isNaN(10)); // false
alert(isNaN("10")); // false
alert(isNaN("blue")); //true
alert(isNaN(true)); //false
```

- 数值转换
Number()函数的转换规则如下。
  - 如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0。  如果是数字值，只是简单的传入和返回。
  - 如果是 null 值，返回 0。
  - 如果是 undefined，返回 NaN。
  - 如果是字符串，遵循下列规则:
    - 如果字符串中只包含数字(包括前面带正号或负号的情况)，则将其转换为十进制数值，即"1" 会变成 1，"123"会变成 123，而"011"会变成 11(注意:前导的零被忽略了);
    - 如果字符串中包含有效的浮点格式，如"1.1"，则将其转换为对应的浮点数值(同样，也会忽 略前导零);
    - 如果字符串中包含有效的十六进制格式，例如"0xf"，则将其转换为相同大小的十进制整 数值;
    - 如果字符串是空的(不包含任何字符)，则将其转换为 0;
    - 如果字符串中包含除上述格式之外的字符，则将其转换为 NaN。
    - 如果是对象，则调用对象的 valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是 NaN，则调用对象的 toString()方法，然后再次依照前面的规则转换返回的字符串值。

多数情况下，我们要解析的都是十进制数值，因此始终将 10 作为第二个参数是 非常必要的。

与 parseInt()函数类似，parseFloat()也是从第一个字符(位置 0)开始解析每个字符。而且 也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。也就是说，字符串中的
第 一个小数点是有效的，而第二个小数点就是无效的了，因此它后面的字符串将被忽略。举例来说， "22.34.5"将会被转换为 22.34。

toString()可以输出以二进制、八进制、十六进制
```
var num = 10;
alert(num.toString()); // 10
alert(num.toString(2)); // 1010
alert(num.toString(8)); // 12
alert(num.toString(10)); //10
alert(num.toString(16)); //a
```

- String()
  - 如果值有 toString()方法，则调用该方法(没有参数)并返回相应的结果; 
  - 如果值是 null，则返回"null";
  - 如果值是 undefined，则返回"undefined"。