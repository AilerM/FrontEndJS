# 4章-变量、作用域和内存问题

## 4.1 基本类型和引用类型的值

### 4.1.3 传递参数
- ECMAScript 中所有函数的参数都是按值传递的

>在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量(即命名参数，或者用 ECMAScript 的概念来说，就是 arguments 对象中的一个元素)。
>在向参数传递引用类型的值时，会把 这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部

### 4.1.4 检测类型
- 虽然在检测基本数据类型时 typeof 是非常得力的助手，但在检测引用类型的值时，这个操作符的 用处不大。

>使用typeof操作符检测函数时，该操作符会返回"function"。在Safari 5及 之前版本和 Chrome 7 及之前版本中使用 typeof 检测正则表达式时，由于规范的原 因，这个操作符也返回"function"。ECMA-262 规定任何在内部实现[[Call]]方法 的对象都应该在应用 typeof 操作符时返回"function"。由于上述浏览器中的正则 表达式也实现了这个方法，因此对正则表达式应用 typeof 会返回"function"。在 IE 和 Firefox 中，对正则表达式应用 typeof 会返回"object"。

## 4.2 执行环境及作用域

当代码在一个环境中执行时，会创建变量对象的一个作用域链(scope chain)。作用域链的用途，是 保证对执行环境有权访问的所有变量和函数的有序访问。

### 4.2.2 没有块级作用域
如果初始化变量时没有使用 var 声明，该变量会自 动被添加到全局环境

## 4.3 垃圾收集GC
JavaScript 是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题
收集机制的原理其实很简单:找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔(或代码执行中预定的收集时间)， 周期性地执行这一操作。
垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于**不再有用的变量打上标记**，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两 个策略。

### 4.3.1 标记清除
JavaScript 中最常用的垃圾收集方式是**标记清除**(mark-and-sweep)
**“标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存。**
永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其 标记为“离开环境”。
垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记(当然，可以使用任何标记方式)。然后，它会**去掉环境中的变量以及被环境中的变量引用的变量的标记**。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成**内存清除**工作，销毁那些带标记的值并回收它们所占用的内存空间

到 2008 年为止，IE、Firefox、Opera、Chrome 和 Safari 的 JavaScript 实现使用的都是标记清除式的 垃圾收集策略(或类似的策略)，只不过垃圾收集的时间间隔互有不同。

### 4.3.2 引用计数
另一种不太常见的垃圾收集策略叫做**引用计数**(reference counting)。引用计数的含义是跟踪记录每 个值被引用的次数。
当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。 
如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取 得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这 个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那 些引用次数为零的值所占用的内存。

严重的问题：循 环引用。循环引用指的是对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含一个指向对象 A 的 引用。请看下面这个例子:

为此，Netscape 在 Navigator 4.0 中放弃了引用计数方式，转而采用标记清除来实现其垃圾收集机制。可是，引用计数导致的麻烦并未就此终结。

我们知道，IE 中有一部分对象并不是原生 JavaScript 对象。例如，其 BOM 和 DOM 中的对象就是
使用 C++以 COM(Component Object Model，组件对象模型)对象的形式实现的，而 COM 对象的垃圾 收集机制采用的就是引用计数策略。因此，即使 IE 的 JavaScript 引擎是使用标记清除策略来实现的，但 JavaScript 访问的 COM 对象依然是基于引用计数策略的。换句话说，只要在 IE 中涉及 COM 对象，就会 存在循环引用的问题。下面这个简单的例子，展示了使用 COM 对象导致的循环引用问题:

```js
var element = document.getElementById("some_element");
var myObject = new Object();
myObject.element = element;
element.someObject = myObject;
// 为了避免类似这样的循环引用问题，最好是在不使用它们的时候手工断开原生 JavaScript 对象与 DOM 元素之间的连接。例如，可以使用下面的代码消除前面例子创建的循环引用:
// myObject.element = null;
// element.someObject = null;
// 将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就 会删除这些值并回收它们占用的内存。

```
>为了解决上述问题，IE9 把 BOM 和 DOM 对象都转换成了真正的 JavaScript 对象。这样，就避免了 两种垃圾收集算法并存导致的问题，也消除了常见的内存泄漏现象。

### 4.3.3 性能问题
垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大 的。在这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题。说到垃圾收集器多长时间运行一 次，不禁让人联想到 IE 因此而声名狼藉的性能问题。IE 的垃圾收集器是根据内存分配量运行的，具体 一点说就是 256 个变量、4096 个对象(或数组)字面量和数组元素(slot)或者 64KB 的字符串。达到 上述任何一个临界值，垃圾收集器就会运行。这种实现方式的问题在于，如果一个脚本中包含那么多变 量，那么该脚本很可能会在其生命周期中一直保有那么多的变量。而这样一来，垃圾收集器就不得不频 繁地运行。结果，由此引发的严重性能问题促使 IE7 重写了其垃圾收集例程。

事实上，在有的浏览器中可以触发垃圾收集过程，但我们不建议读者这样做。在 IE 中，调用 window.CollectGarbage()方法会立即执行垃圾收集。在 Opera 7 及更 高版本中，调用 window.opera.collect()也会启动垃圾收集例程。

### 4.3.4 管理内存
因此，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为**执行中的代码只保存必要的数据**。
一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个 做法叫做**解除引用**(dereferencing)。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在 它们离开执行环境时自动被解除引用，如下面这个例子所示:

```js
function createPerson(name){
    var localPerson = new Object();
    localPerson.name = name;
}
var globalPerson = createPerson("Nicholas"); // 手工解除 globalPerson 的引用
globalPerson = null;
```
不过，解除一个值的引用并不意味着自动回收该值所占用的内存。**解除引用的真正作用是让值脱离 执行环境，以便垃圾收集器下次运行时将其回收**


# 总结

基本类型值和引用类型值具 有以下特点: 
  - 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中
  - 从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本;
  - 引用类型的值是对象，保存在堆内存中;
  - 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针;
  - 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象;

执行环境
  - 每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链;
  - 函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含(父)环境，乃至全局环境
  - 全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据;
  - 变量的执行环境有助于确定应该何时释放内存。